<!-- --> {{< fm-bliki.html}}{{$title}}Non-Distributed Microservices{{/title}}{{$author}}Fabrizio Montesi{{/author}}{{$date}}27 September 2024{{/date}}{{$subHeader}}Title originally used in a <a href="https://fmontesi.github.io/2015/06/09/non-distributed-microservices.html">previous blog post</a> of mine. Much has changed in Jolie since then, so please refer to this article in the future.{{/subHeader}}{{$content}}

<img src="/images/blue-hexagons.jpg" height="200" alt="Blue hexagons" style="float: left; padding: 0; margin: 1em; margin-left: 0;" />

When I teach somebody (students or professionals) how to program microservices, I try to follow a gradual path.
Unfortunately, there are simply too many things to worry about when you program Microservice Architectures (MSAs). If you are not an expert, you are likely going to be overwhelmed by complexity. Even if you are an expert, you may be better off with the [MonolithFirst](http://martinfowler.com/bliki/MonolithFirst.html) approach. That is, the idea of developing a monolithic architecture and then gradually peel microservices off it as needed.
But why are Microservices so complicated? The main reason is that an MSA is typically distributed, and distributed computing is hard (see [the fallacies of distributed computing](http://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)).
So, intuitively, it is much simpler to start with a monolith, and switch to microservices later. Unfortunately intuition is not really met by reality here. Developing a monolith does not force programmers to make their components modular and loosely-coupled enough to be smoothly ported to microservices; for example, it is way too tempting to share resources and/or develop APIs that are not suitable for message passing. Most probably, your initial monolith will end up being a&nbsp;<a href="http://martinfowler.com/bliki/SacrificialArchitecture.html" target="_blank">SacrificialArchitecture</a>. This is not necessarily a bad thing: many successes were built on top of sacrificing architectures. I am more worried about the fact that this is not really a smooth learning process: develop a monolith, learn something, now change everything.<br /><br />NMSAs is a style where you program your system <i>as if it were an MSA, but without the distribution</i>. In an NMSA, Microservices are run concurrently in the same container (in our case, a Jolie-controlled JVM). It is an attempt at providing an easier setting for learners and experimenters to start with: no distributed computing means no fallacies of distributed computing. What can you learn in such an environment? A great deal, including:<br /><br /><ul><li>You can learn how to develop loosely-coupled service interfaces, and how to deal with message passing in the easier setting of a perfectly-working "network".</li><li>You can learn how to test your services, and how to automatise testing.</li><li>You can learn how to monitor service execution.</li></ul>The idea is to first approach the programming of microservices in this simpler ("fake", if you like) setting, and learn how to deal with distribution later. In the Jolie programming language, this path from NMSAs to MSAs is supported by the language itself.

<!-- <div dir="ltr"><br /><a href="http://3.bp.blogspot.com/-A3lcjBFxVn8/VXaTCbX919I/AAAAAAAAGT4/sqRXwRMczJ8/s1600/puzzle-654957_1280.jpg" imageanchor="1" style="clear: left; display: inline !important; float: left; margin-bottom: 1em; margin-right: 1em; text-align: center;"><img border="0" height="150" src="http://3.bp.blogspot.com/-A3lcjBFxVn8/VXaTCbX919I/AAAAAAAAGT4/sqRXwRMczJ8/s200/puzzle-654957_1280.jpg" width="200" /></a><br />Thanks to Martin's <a href="https://github.com/jolie/jolie/pull/45" target="_blank">great</a>&nbsp;<a href="https://github.com/jolie/jolie/pull/48" target="_blank">help</a>, <a href="http://www.jolie-lang.org/" target="_blank">Jolie</a> 1.4 will have support for <a href="http://docs.jolie-lang.org/#!documentation/architectural_composition/internal_services.html" target="_blank">Internal Services</a>&nbsp;and enhanced <a href="http://docs.jolie-lang.org/#!documentation/architectural_composition/embedding_jolie.html" target="_blank">local locations</a>. If you feel like testing, you can already find it in <a href="https://github.com/jolie/jolie" target="_blank">our git repository</a>&nbsp;(see <a href="http://jolie-lang.org/downloads.html" target="_blank">compile from sources</a>).<br />While these features do not add any essential expressiveness to Jolie, they make it easier to program non-distributed microservice architectures (NMSA here for brevity). "Wait" - I hear you - "NMSAs?"<br /><br /><a name='more'></a><br /><h2>Non-distributed Microservice Architectures (NMSAs)</h2><div><br /><br /><h2>NMSAs first...</h2></div>NMSAs are created in Jolie by using <a href="http://docs.jolie-lang.org/#!documentation/architectural_composition/embedding.html" target="_blank">embedded</a> or <a href="http://docs.jolie-lang.org/#!documentation/architectural_composition/internal_services.html" target="_blank">internal services</a>, i.e., services that run locally in the same container of the main service program. I will refer to such services as "local services" here. All components that you can write in Jolie are services, therefore all the architectures that you write in Jolie are service-oriented by design. This means that components cannot share state, and must interact through service interfaces based on message passing. What happens behind the scenes depends on the deployment information that you specify for your services, which is kept separate from the application logic. If the case of a local service, messages are efficiently communicated via shared memory, but without breaking the message passing abstraction given to the programmer.<br /><br />Here is a toy example of a program using local services (you can of course split this in multiple files; oh, and I'm omitting what happens in case we do not find some records or files):<br /><br /><br /><span style="font-family: 'Courier New', Courier, monospace;">service Images {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; Interfaces: ImagesIface</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; main {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; get( request )( img ) {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fetch@ImageDB( request )</span><span style="font-family: 'Courier New', Courier, monospace;">( img )</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; }</span><br /><span style="font-family: 'Courier New', Courier, monospace;">}</span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><span style="font-family: 'Courier New', Courier, monospace;">service Products {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; Interfaces: ProductsIface</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; main {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; get( request )( response ) {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query@ProductDB</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( "select name,desc,imageurl from products where id=:id"</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { .id = request.id } )</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( response )</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; }</span><br /><span style="font-family: 'Courier New', Courier, monospace;">}</span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><span style="font-family: 'Courier New', Courier, monospace;">main {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; viewProduct( request )( product ) {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; get@Products( { .id = request.id } )( product );</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; if ( request.embedImage ) {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get@Images( { .url = product.imageurl } )( product.image )</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; }</span><br /><span style="font-family: 'Courier New', Courier, monospace;">}</span><br /><div><br />The program above is a simple service to access product information. It offers one operation, viewProduct, that clients can invoke with a message containing the id of the product they want to see (as a subnode of request). The service then invoke the internal service Products, which queries a database for some basic information and returns it. The product information contains an URL to an image depicting the product. Then, the main program checks whether the original client requested the image to be embedded in the response (useful, e.g., for mobile applications that want to minimize the number of message exchanges); if positive, the image is added to the response by fetching it from the Images service.<br /><br />The main service, Images, and Products communicate using shared memory in the Jolie implementation of internal services. Communications are therefore always going to succeed, but each service has its own interface and state and the style is still message passing. Hence, internal services can be used to teach how to design a loosely-coupled architecture.<br /><br /></div><h2>...and MSAs later</h2><div>NMSAs are expressive enough to teach, e.g., how to deal with concurrency issues (each service has its own processes), message passing interfaces, and good API design. They are also fairly easy to achieve, relieving beginners from the frustrations of service deployment.<br /><br />After a while, however, an NMSA that needs to scale has to evolve into an MSA, by taking some internal services and making them distributed. Distributing an internal service in Jolie is easy. Simply put, take the code of the internal service you want to distribute and execute it with a separate interpreter in another machine (<a href="http://www.italianasoftware.com/products.html" target="_blank">Jolie Enterprise</a> automatises this job for you in a cloud environment, but you can use the tools of your choice).<br /><br />The main service now needs to be updated to refer to Images and Products as external distributed services:<br /><br /><span style="font-family: 'Courier New', Courier, monospace;">outputPort Images {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">Location: "socket://images.example:8080"</span><br /><span style="font-family: 'Courier New', Courier, monospace;">Protocol: sodep</span><br /><span style="font-family: 'Courier New', Courier, monospace;">Interfaces: ImagesIface</span><br /><span style="font-family: 'Courier New', Courier, monospace;">}</span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><span style="font-family: 'Courier New', Courier, monospace;">outputPort Products {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">Location: "socket://products.example:8080"</span><br /><span style="font-family: 'Courier New', Courier, monospace;">Protocol: sodep</span><br /><span style="font-family: 'Courier New', Courier, monospace;">Interfaces: ProductsIface</span><br /><span style="font-family: 'Courier New', Courier, monospace;">}</span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><span style="font-family: 'Courier New', Courier, monospace;">main {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; viewProduct( request )( product ) {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; get@Products( { .id = request.id } )( product );</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; if ( request.embedImage ) {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get@Images( { .url = product.imageurl } )( product.image )</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; }</span><br /><span style="font-family: 'Courier New', Courier, monospace;">}</span><br /><br />Basically, we have replaced the code for each internal service with a respective <a href="http://docs.jolie-lang.org/#!documentation/basics/communication_ports.html" target="_blank">output port</a>. The rest of the code does not change (again, a key aspect of developing services with Jolie is that deployment is kept as separate as possible from behaviour). However, now the system is distributed. Among other consequences of this, communications with services Products and Images may now fail! In practice, this means that the invocations get@Products and get@Images can throw network-related faults now, and we must account for that. If we leave the code like this, such faults are going to be automatically propagated to clients. This may be undesirable. A better strategy could be:<br /><br /><ul><li>If we fail to get the product information, we immediately return an informative fault to the client.</li><li>If we manage to get the product information but fail to get its image, we should return at least the product information with a placeholder blank image.</li></ul><div>We update the code accordingly, using <a href="http://docs.jolie-lang.org/#!documentation/fault_handling/basics.html" target="_blank">dynamic fault handlers</a>:</div><br /><br /><br /><span style="font-family: 'Courier New', Courier, monospace;">main {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; viewProduct( request )( product ) {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; scope( s ) {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; install( default =&gt; throw( ProductsCurrentlyUnavailable ) );</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get@Products( { .id = request.id } )( product )</span><span style="font-family: 'Courier New', Courier, monospace;">;</span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; install( default =&gt; product.image = BLANK_IMAGE );</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ( request.embedImage ) {</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get@Images( { .url = product.imageurl } )( product.image )</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br /><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; }</span><br /><span style="font-family: 'Courier New', Courier, monospace;">}</span><br /><br />There we go. Now our code accounts for network errors (actually any error, since I used the default handler, which catches any fault). There are, of course, many other things to watch out for, e.g., distributed monitoring, crash recovery, and performance. However, this small example gives already an idea of the overall methodology.</div><h2>Gotcha</h2><div>Although Jolie does its best in not allowing resource sharing among services (they simply cannot be shared, by the language syntax), this can always be circumvented via external side-effects. For example, two internal service may share access to the same file system. However, this can also be abstracted from: in Jolie all accesses to the file system happen through the File service from the standard library which, being a service, can also be distributed.<br /><br /><h2>Conclusions</h2><div>The microservices style arises out of practical needs, and although it should be used only when necessary, sometimes it is appropriate. I believe that we should find ways to guide a smoother transition from monoliths to microservices, and that finding such ways is possible. This is a rough attempt at giving a first piece of the puzzle towards building such a transition model.</div><div><br /></div><br />PS: I should really try to come up with better acronyms.<br />PPS: If you have interesting examples to share in other languages, please feel free to do so!</div></div> -->


<!-- --> {{/content}}{{/fm-bliki.html}}