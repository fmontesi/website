{"journals/corr/Cruz-FilipeLM16":{"peerReviewedVersion":"conf\/fossacs\/Cruz-FilipeLM17","abstract":"Choreographies are global descriptions of interactions among concurrent\ncomponents, most notably used in the settings of verification (e.g., Multiparty\nSession Types) and synthesis of correct-by-construction software (Choreographic\nProgramming). They require a top-down approach: programmers first write\nchoreographies, and then use them to verify or synthesize their programs.\nHowever, most existing software does not come with choreographies yet, which\nprevents their application.\n  To attack this problem, we propose a novel methodology (called choreography\nextraction) that, given a set of programs or protocol specifications,\nautomatically constructs a choreography that describes their behavior. The key\nto our extraction is identifying a set of paths in a graph that represents the\nsymbolic execution of the programs of interest. Our method improves on previous\nwork in several directions: we can now deal with programs that are equipped\nwith a state and internal computation capabilities; time complexity is\ndramatically better; we capture programs that are correct but not necessarily\nsynchronizable, i.e., they work because they exploit asynchronous\ncommunication."},"conf/concur/MontesiY13":{"pdf":"my13","abstract":"We propose a new programming model that supports a compositionality of choreographies. The key of our approach is the introduction of partial choreographies, which can mix global descriptions with communications among external peers. We prove that if two choreographies are composable, then the endpoints independently generated from each choreography are also composable, preserving their typability and deadlock-freedom. The usability of our framework is demonstrated by modelling an industrial use case implemented in a tool for Web Services, Jolie."},"conf/sac/MontesiW18":{"pdf":"mw18","abstract":"We analyse different deployment setups for circuit breaker, a design pattern for preventing cascading failures by guarding calls towards a target service. Then, we define a unifying implementation strategy in the setting of microservices, by using the Jolie programming language. Our implementation captures all setups with a single program, by interpreting a circuit breaker as a decorator that is generic on the interface of its target service."},"journals/corr/TchitchiginSMEM16":{"pdf":"tsmem16","abstract":"Jolie is the first language for microservices and it is currently dynamically\ntype checked. This paper considers the opportunity to integrate dynamic and\nstatic type checking with the introduction of refinement types, verified via\nSMT solver. The integration of the two aspects allows a scenario where the\nstatic verification of internal services and the dynamic verification of\n(potentially malicious) external services cooperates in order to reduce testing\neffort and enhancing security."},"journals/tcs/Cruz-FilipeM20":{"path":"a-core-model-for-choreographic-programming-journal","pdf":"cm20","abstract":"<p>Choreographic Programming is a paradigm for developing concurrent programs that are deadlock-free by construction, as a result of programming communications declaratively and then synthesising process implementations automatically. Despite strong interest on choreographies, a foundational model that explains which computations can be performed with the hallmark constructs of choreographies is still missing.<\/p><p>In this work, we introduce Core Choreographies (CC), a model that includes only the core primitives of choreographic programming. Every computable function can be implemented as a choreography in CC, from which we can synthesise a process implementation where independent computations run in parallel. We discuss the design of CC and argue that it constitutes a canonical model for choreographic programming.<\/p>"},"journals/corr/Cruz-FilipeM16a":{"peerReviewedVersion":"conf\/forte\/Cruz-FilipeM16","abstract":"Choreographic Programming is a development methodology for concurrent\nsoftware that guarantees correctness by construction. The key to this paradigm\nis to disallow mismatched I\/O operations in programs, called choreographies,\nand then mechanically synthesise distributed implementations in terms of\nstandard process models via a mechanism known as EndPoint Projection (EPP).\n  Despite the promise of choreographic programming, there is still a lack of\npractical evaluations that illustrate the applicability of choreographies to\nconcrete computational problems with standard concurrent solutions. In this\nwork, we explore the potential of choreographies by using Procedural\nChoreographies (PC), a model that we recently proposed, to write distributed\nalgorithms for sorting (Quicksort), solving linear equations (Gaussian\nelimination), and computing Fast Fourier Transform. We discuss the lessons\nlearned from this experiment, giving possible directions for the usage and\nfuture improvements of choreography languages."},"journals/corr/DragoniGLMMMS16":{"peerReviewedVersion":"books\/sp\/17\/DragoniGLMMMS17","pdf":"dglmmms16","abstract":"Microservices is an architectural style inspired by service-oriented\ncomputing that has recently started gaining popularity. Before presenting the\ncurrent state-of-the-art in the field, this chapter reviews the history of\nsoftware architecture, the reasons that led to the diffusion of objects and\nservices first, and microservices later. Finally, open problems and future\nchallenges are introduced. This survey primarily addresses newcomers to the\ndiscipline, while offering an academic viewpoint on the topic. In addition, we\ninvestigate some practical issues and point out some potential solutions."},"conf/aina/SafinaMMR16":{"abstract":"Microservices is an architectural style inspired by service-oriented computing that has recently started gaining popularity. Jolie is a programming language based on the microservices paradigm: the main building block of Jolie systems are services, in contrast to, e.g., functions or objects. The primitives offered by the Jolie language elicit many of the recurring patterns found in microservices, like load balancers and structured processes. However, Jolie still lacks some useful constructs for dealing with message types and data manipulation that are present in service-oriented computing. In this paper, we focus on the possibility of expressing choices at the level of data types, a feature well represented in standards for Web Services, e.g., WSDL. We extend Jolie to support such type choices, and enable Jolie processes to act on data generically (without knowing which type it has in the choice). We show the impact of our implementation on some of the typical scenarios found in microservice systems. This shows how computation can move from a process-driven to a data-driven approach, and leads to the preliminary identification of recurring communication patterns that can be shaped as design patterns."},"conf/birthday/GiallorenzoLMSZ20":{"pdf":"glmsz20","abstract":"Serverless computing is a paradigm for programming cloud applications in terms of stateless functions, executed and scaled in proportion to inbound requests. Here, we revisit SKC, a calculus capturing the essential features of serverless programming. By exploring the design space of the language, we refined the integration between the fundamental features of the two calculi that inspire SKC: the λ- and the π-calculus. That investigation led us to a revised syntax and semantics, which support an increase in the expressiveness of the language. In particular, now function names are first-class citizens and can be passed around. To illustrate the new features, we present step-by-step examples and two non-trivial use cases from artificial intelligence, which model, respectively, a perceptron and an image tagging system into compositions of serverless functions. We also illustrate how SKC supports reasoning on serverless implementations, i.e., the underlying network of communicating, concurrent, and mobile processes which execute serverless functions in the cloud. To that aim, we show an encoding from SKC to the asynchronous π-calculus and prove it correct in terms of an operational correspondence."},"conf/lopstr/KjaerCM22":{"pdf":"kcm22","abstract":"<p>Choreographies are formal descriptions of distributed systems, which focus on the way in which participants communicate. While they are useful for analysing protocols, in practice systems are written directly by specifying each participant\u2019s behaviour. This created the need for choreography extraction: the process of obtaining a choreography that faithfully describes the collective behaviour of all participants in a distributed protocol.<\/p><p>Previous works have addressed this problem for systems with a predefined, finite number of participants. In this work, we show how to extract choreographies from system descriptions where the total number of participants is unknown and unbounded, due to the ability of spawning new processes at runtime. This extension is challenging, since previous algorithms relied heavily on the set of possible states of the network during execution being finite.<\/p>"},"conf/popl/CarboneM13":{"pdf":"cm13","abstract":"Over the last decade, global descriptions have been successfully employed for the verification and implementation of communicating systems, respectively as protocol specifications and choreographies. In this work, we bring these two practices together by proposing a purely-global programming model. We show a novel interpretation of asynchrony and parallelism in a global setting and develop a typing discipline that verifies choreographies against protocol specifications, based on multiparty sessions. Exploiting the nature of global descriptions, our type system defines a new class of deadlock-free concurrent systems (deadlock-freedom-bydesign), provides type inference, and supports session mobility. We give a notion of Endpoint Projection (EPP) which generates correct entity code (as π-calculus terms) from a choreography. Finally, we evaluate our approach by providing a prototype implementation for a concrete programming language and by applying it to some examples from multicore and service-oriented programming."},"conf/ictac/Cruz-FilipeMP21":{"pdf":"cmp21b","abstract":"<p>Choreographic programming is a paradigm for developing concurrent and distributed systems, where programs are choreographies that define, from a global viewpoint, the computations and interactions that communicating processes should enact. Choreography compilation translates choreographies into the local definitions of process behaviours, given as terms in a process calculus.<\/p><p>Proving choreography compilation correct is challenging and error-prone, because it requires relating languages in different paradigms (global interactions vs local actions) and dealing with a combinatorial explosion of proof cases. We present the first certified program for choreography compilation for a nontrivial choreographic language supporting recursion.<\/p>"},"conf/ecoop/Cruz-FilipeGLMP23":{"pdf":"cglmp23","abstract":"<p>Choreographic programming is a paradigm for concurrent and distributed software, whereby descriptions of the intended communications (choreographies) are automatically compiled into distributed code with strong safety and liveness properties (e.g., deadlock-freedom).<\/p><p>Recent efforts tried to combine the theories of choreographic programming and higher-order functional programming, in order to integrate the benefits of the former with the modularity of the latter. However, they do not offer a satisfactory theory of compilation compared to the literature, because of important syntactic and semantic shortcomings: compilation is not modular (editing a part might require recompiling everything) and the generated code can perform unexpected global synchronisations.<\/p><p>In this paper, we find that these shortcomings are not mere coincidences. Rather, they stem from genuine new challenges posed by the integration of choreographies and functions: knowing which participants are involved in a choreography becomes nontrivial, and divergence in applications requires rethinking how to prove the semantic correctness of compilation.<\/p><p>We present a novel theory of compilation for functional choreographies that overcomes these challenges, based on types and a careful design of the semantics of choreographies and distributed code. The result: a modular notion of compilation, which produces code that is deadlock-free and correct (it operationally corresponds to its source choreography).<\/p>"},"journals/corr/abs-2005-09520":{"pdf":"gmp20","abstract":"We present Choral, the first language for programming choreographies\n(multiparty protocols) that builds on top of mainstream programming\nabstractions: in Choral, choreographies are objects. Given a choreography that\ndefines interactions among some roles (Alice, Bob, etc.), an implementation for\neach role in the choreography is automatically generated by a compiler. These\nimplementations are libraries in pure Java, which developers can modularly\ncompose in their own programs to participate correctly in choreographies."},"journals/corr/GabbrielliGM15":{"peerReviewedVersion":"conf\/forte\/GiallorenzoMG18","pdf":"ggm15","abstract":"Choreographic Programming is a correct-by-construction paradigm where a\ncompilation procedure synthesises deadlock-free, concurrent, and distributed\ncommunicating processes from global, declarative descriptions of\ncommunications, called choreographies. Previous work used choreographies for\nthe synthesis of programs. Alas, there is no formalisation that provides a\nchain of correctness from choreographies to their implementations. This problem\noriginates from the gap between existing theoretical models, which abstract\ncommunications using channel names (\\`a la CCS\/{\\pi}-calculus), and their\nimplementations, which use low-level mechanisms for message routing. As a\nsolution, we propose the theoretical framework of Applied Choreographies. In\nthe framework, developers write choreographies in a language that follows the\nstandard syntax and name-based communication semantics of previous works. Then,\nthey use a compilation procedure to transform a choreography into a low-level,\nimplementation-adherent calculus of Service-Oriented Computing (SOC). To manage\nthe complexity of the compilation, we divide its formalisation and proof in\nthree stages, respectively dealing with: a) the translation of name-based\ncommunications into their SOC equivalents (namely, using correlation mechanisms\nbased on message data); b) the projection of a choreography into a composition\nof partial, single-participant choreographies (towards their translation into\nSOC processes); c) the translation of partial choreographies and the\ndistribution of choreography-level state into SOC processes. We provide results\nof behavioural correspondence for each stage. Thus, given a choreography\nspecification, we guarantee to synthesise its faithful and deadlock-free\nservice-oriented implementation."},"M10":{"abstract":"The original MSc thesis in Computer Science on the Jolie programming language."},"conf/lopstr/CarboneCMM18":{"pdf":"ccmm18","abstract":"We present Multiparty Classical Choreographies (MCC), a language model where global descriptions of communicating systems (choreographies) implement typed multiparty sessions. Typing is achieved by generalising classical linear logic to judgements that explicitly record parallelism by means of hypersequents. Our approach unifies different lines of work on choreographies and processes with multiparty sessions, as well as their connection to linear logic. Thus, results developed in one context are carried over to the others. Key novelties of MCC include support for server invocation in choreographies, as well as logic-driven compilation of choreographies with replicated processes."},"journals/ftpl/AnconaBB0CDGGGH16":{"pdf":"btipl","abstract":"A recent trend in programming language research is to use behavioral type theory to ensure various correctness properties of largescale, communication-intensive systems. Behavioral types encompass concepts such as interfaces, communication protocols, contracts, and choreography. The successful application of behavioral types requires a solid understanding of several practical aspects, from their representation in a concrete programming language, to their integration with other programming constructs such as methods and functions, to design and monitoring methodologies that take behaviors into account. This survey provides an overview of the state of the art of these aspects, which we summarize as the pragmatics of behavioral types."},"journals/corr/abs-2303-04678":{"abstract":"We present PolyChor$\\lambda$, a language for higher-order functional\n\\emph{choreographic programming} -- an emerging paradigm by which programmers\nwrite the desired cooperative behaviour of a system of communicating processes\nand then compile it into distributed implementations for each process, a\ntranslation called \\emph{endpoint projection}. Unlike its predecessor,\nChor$\\lambda$, PolyChor$\\lambda$ has both type and \\emph{process} polymorphism\ninspired by System F$_\\omega$. That is, PolyChor$\\lambda$ is the first\n(higher-order) functional choreographic language which gives programmers the\nability to write generic choreographies and determine the participants at\nruntime. This novel combination of features also allows PolyChor$\\lambda$\nprocesses to communicate \\emph{distributed values}, leading to a new and\nintuitive way to write delegation. While some of the functional features of\nPolyChor$\\lambda$ give it a weaker correspondence between the semantics of\nchoreographies and their endpoint-projected concurrent systems than some other\nchoreographic languages, we still get the hallmark end result of choreographic\nprogramming: projected programs are deadlock-free by design."},"conf/sefm/LaneseGMZ08":{"path":"bridging-the-gap-between-interaction-and-process-oriented-choreographies","pdf":"lgmz08","abstract":"In service oriented computing, choreography languages are used to specify multi-party service compositions. Two main approaches have been followed: the interaction-oriented approach of WS-CDL and the process-oriented approach of BPEL4Chor. We investigate the relationship between them.In particular, we consider several interpretations for interaction-oriented choreographies spanning from synchronous to asynchronous communication. Under each of these interpretations we characterize the class of interaction-oriented choreographies which have a process-oriented counterpart, and we formalize the notion of equivalence between the initial interaction-oriented choreography and the corresponding process-oriented one."},"journals/corr/abs-2303-03983":{"pdf":"lm23-arxiv","abstract":"Choreographic programming is a programming paradigm, whereby the overall\nbehaviour of a distributed system is coded as a choreography from a global\nviewpoint. The choreography can then be automatically compiled (projected) to a\ncorrect implementation for each participant.\n  Choreographic programming relieves the programmer from manually writing the\nseparate send and receive actions performed by participants and avoids the\nproblem of communication mismatches. However, the applicability of this\nparadigm in the real world remains largely unexplored for two reasons. First,\nwhile there have been several proposals of choreographic programming languages,\nnone of them have been used to implement a realistic, widely-used protocol.\nThus there is a lack of experience on how realistic choreographic programs are\nstructured and on the relevance of the features explored in theoretical models.\nSecond, applications of choreographic programming shown so far are intrusive\nsince each participant must use exactly the code projected from the\nchoreography. This prevents using the projected code with existing third-party\nimplementations of some participants.\n  We carry out the first development in choreographic programming of a\nwidespread real-world protocol: the Internet Relay Chat (IRC) protocol. Our\ndevelopment is based on Choral, an object-oriented choreographic programming\nlanguage. Two of Choral's features are key to our implementation: higher-order\nchoreographies for modelling the complex interaction patterns due to IRC's\nasynchronous nature; and user-definable communication semantics for achieving\ninteroperability with third-party implementations. We also discover a missing\npiece: the capability of statically detecting that choices on alternative\ndistributed behaviours are appropriately communicated by means of message\ntypes. We extend the Choral compiler with an elegant solution based on\nsubtyping."},"conf/itp/Cruz-FilipeM23":{"pdf":"cm23","abstract":"<p>Choreographic programming is a paradigm where developers write the global specification (called choreography) of a communicating system, and then a correct-by-construction distributed implementation is compiled automatically. Unfortunately, it is possible to write choreographies that cannot be compiled, because of issues related to an agreement property known as knowledge of choice. This forces programmers to reason manually about implementation details that may be orthogonal to the protocol that they are writing.<\/p><p>Amendment is an automatic procedure for repairing uncompilable choreographies. We present a formalisation of amendment from the literature, built upon an existing formalisation of choreographic programming. However, in the process of formalising the expected properties of this procedure, we discovered a subtle counterexample that invalidates the original published and peer-reviewed pen-and-paper theory. We discuss how using a theorem prover led us to both finding the issue, and stating and proving a correct formulation of the properties of amendment.<\/p>"},"conf/birthday/GabbrielliGGMM16":{"pdf":"gggmm16","abstract":"Microservices is an emerging paradigm for the development of distributed systems that, originating from Service-Oriented Architecture, focuses on the small dimension, the loose coupling, and the dynamic topology of services. Microservices are particularly appropriate for the development of distributed systems in the Cloud. However, their dynamic nature calls for suitable techniques for their automatic deployment. In this paper we address this problem and we propose JRO (Jolie Redeployment Optimiser), a tool for the automatic and optimised deployment of microservices written in the Jolie language. The tool uses Zephyrus, a state of the art tool that automatically generates a fully detailed ServiceOriented Architecture configuration starting from a partial and abstract description of the target application."},"journals/peerj-cs/BerardiGMMMP22":{"pdf":"bgmmmp22","abstract":"Microservices is an emerging paradigm for developing distributed systems. With their widespread adoption, more and more work investigated the relation between microservices and security. Alas, the literature on this subject does not form a well-defined corpus: it is spread over many venues and composed of contributions mainly addressing specific scenarios or needs. In this work, we conduct a systematic review of the field, gathering 290 relevant publications\u2014at the time of writing, the largest curated dataset on the topic. We analyse our dataset along two lines: (a) quantitatively, through publication metadata, which allows us to chart publication outlets, communities, approaches, and tackled issues; (b) qualitatively, through 20 research questions used to provide an aggregated overview of the literature and to spot gaps left open. We summarise our analyses in the conclusion in the form of a call for action to address the main open challenges."},"journals/corr/abs-2202-11397":{"peerReviewedVersion":"conf\/coordination\/GiallorenzoMPR22","abstract":"We formally define and implement a translation from domain models in the\nLEMMA modelling framework to microservice APIs in the Jolie programming\nlanguage. Our tool enables a software development process whereby microservice\narchitectures can first be designed with the leading method of Domain-Driven\nDesign, and then corresponding data types and service interfaces (APIs) in\nJolie are automatically generated. Developers can extend and use these APIs as\nguides in order to produce compliant implementations. Our tool thus contributes\nto enhancing productivity and improving the design adherence of microservices."},"books/sp/17/DragoniGLMMMS17":{"path":"microservices-yesterday-today-and-tomorrow","pdf":"dglmmms17","abstract":"Microservices is an architectural style inspired by service-oriented computing that has recently gaining popularity. Before presenting the current state-of-the-art in the field, this chapter reviews the history of software architecture, the reasons that led to the diffusion of objects and services first, and microservices later. Finally, open problems and future challenges are introduced. This survey primarily addresses newcomers to the discipline, while offering an academic viewpoint on the topic. In addition, we investigate some practical issues and point out some potential solutions."},"conf/microservices/2019":{"path":"proceedings-microservices-2017-2019","pdf":"cgmprs19","abstract":"Joint Post-proceedings of the First and Second International Conference on Microservices, Microservices 2017\/2019."},"journals/corr/abs-1801-08107":{"abstract":"Modular programming is a cornerstone in software development, as it allows to\nbuild complex systems from the assembly of simpler components, and support\nreusability and substitution principles. In a distributed setting, component\nassembly is supported by communication that is often required to follow a\nprescribed protocol of interaction. In this paper, we present a language for\nthe modular development of distributed systems, where the assembly of\ncomponents is supported by a choreography that specifies the communication\nprotocol. Our language allows to separate component behaviour, given in terms\nof reactive data ports, and choreographies, specified as first class entities.\nThis allows us to consider reusability and substitution principles for both\ncomponents and choreographies. We show how our model can be compiled into a\nmore operational perspective in a provably-correct way, and we present a typing\ndiscipline that addresses communication safety and progress of systems, where a\nnotion of substitutability naturally arises."},"journals/corr/abs-2111-03701":{"peerReviewedVersion":"conf\/ictac\/Cruz-FilipeGLMP22","abstract":"Choreographic programming is an emerging programming paradigm for concurrent\nand distributed systems, whereby developers write the communications that\nshould be enacted and then a distributed implementation is automatically\nobtained by means of a compiler. Theories of choreographic programming\ntypically come with strong theoretical guarantees about the compilation\nprocess, most notably: the generated implementations operationally correspond\nto their source choreographies and are deadlock-free.\n  Currently, the most advanced incarnation of the paradigm is Choral, an\nobject-oriented choreographic programming language that targets Java. Choral\ndeviated significantly from known theories of choreographies, and introduced\nthe possibility of expressing higher-order choreographies (choreographies\nparameterised over choreographies) that are fully distributed. As a\nconsequence, it is unclear if the usual guarantees of choreographies can still\nhold in the more general setting of higher-order ones.\n  We introduce Chor{\\lambda}, the first functional choreographic programming\nlanguage: it introduces a new formulation of the standard communication\nprimitive found in choreographies as a function, and it is based upon the\n{\\lambda}-calculus. Chor{\\lambda} is the first theory that explains the core\nideas of higher-order choreographic programming (as in Choral). Bridging the\ngap between practice and theory requires developing a new evaluation strategy\nand typing discipline for {\\lambda} terms that accounts for the distributed\nnature of computation in choreographies. We illustrate the expressivity of\nChor{\\lambda} with a series of examples, which include reconstructions of the\nkey examples from the original presentation of Choral. Our theory supports the\nexpected properties of choreographic programming and bridges the gap between\nthe communities of functional and choreographic programming."},"journals/jisis/BravettiLMM15":{"abstract":"Special Issue on Service-Oriented Architectures and Programming (SOAP 2014)."},"conf/coordination/GiallorenzoMPRS21":{"pdf":"gmprs21","abstract":"In microservices, Model-Driven Engineering (MDE) has emerged as a powerful methodology for architectural design. Independently, the community of programming languages has investigated new linguistic abstractions for effective microservice development. Here, we present the first preliminary study of how the two approaches can cross-pollinate, taking the LEMMA framework and the Jolie programming language as respective representatives. We establish a common ground for comparing the two technologies in terms of metamodels, discuss practical enhancements that can be derived from the comparison, and present some directions for future work that arise from our new viewpoint."},"conf/wsfm/Montesi15":{"pdf":"m15","abstract":"We present an overview of some recent efforts aimed at the development of Choreographic Programming, a programming paradigm for the production of concurrent software that is guaranteed to be correct by construction from global descriptions of communication behaviour."},"journals/corr/abs-2207-08884":{"peerReviewedVersion":"conf\/lopstr\/KjaerCM22","abstract":"Choreographies are formal descriptions of distributed systems, which focus on\nthe way in which participants communicate. While they are useful for analysing\nprotocols, in practice systems are written directly by specifying each\nparticipant's behaviour. This created the need for choreography extraction: the\nprocess of obtaining a choreography that faithfully describes the collective\nbehaviour of all participants in a distributed protocol.\n  Previous works have addressed this problem for systems with a predefined,\nfinite number of participants. In this work, we show how to extract\nchoreographies from system descriptions where the total number of participants\nis unknown and unbounded, due to the ability of spawning new processes at\nruntime. This extension is challenging, since previous algorithms relied\nheavily on the set of possible states of the network during execution being\nfinite."},"journals/acta/CarboneMSY17":{"path":"multiparty-session-types-as-coherence-proofs-journal","pdf":"cmsy17","abstract":"We propose a Curry-Howard correspondence between a language for programming multiparty sessions and a generalisation of Classical Linear Logic (CLL). In this framework, propositions correspond to the local behaviour of a participant in a multiparty session type, proofs to processes, and proof normalisation to executing communications. Our key contribution is generalising duality, from CLL, to a new notion of n-ary compatibility, called coherence. Building on coherence as a principle of compositionality, we generalise the cut rule of CLL to a new rule for composing many processes communicating in a multiparty session. We prove the soundness of our model by showing the admissibility of our new rule, which entails deadlock-freedom via our correspondence."},"journals/corr/abs-1903-07962":{"peerReviewedVersion":"conf\/coordination\/GabbrielliGLMPZ19","abstract":"Serverless computing, also known as Functions-as-a-Service, is a recent\nparadigm aimed at simplifying the programming of cloud applications. The idea\nis that developers design applications in terms of functions, which are then\ndeployed on a cloud infrastructure. The infrastructure takes care of executing\nthe functions whenever requested by remote clients, dealing automatically with\ndistribution and scaling with respect to inbound traffic.\n  While vendors already support a variety of programming languages for\nserverless computing (e.g. Go, Java, Javascript, Python), as far as we know\nthere is no reference model yet to formally reason on this paradigm. In this\npaper, we propose the first formal programming model for serverless computing,\nwhich combines ideas from both the $\\lambda$-calculus (for functions) and the\n$\\pi$-calculus (for communication). To illustrate our proposal, we model a\nreal-world serverless system. Thanks to our model, we are also able to capture\nand pinpoint the limitations of current vendor technologies, proposing possible\namendments."},"M23":{"abstract":"In concurrent and distributed systems, processes can complete tasks together by playing their parts in a joint plan. The plan, or protocol, can be written as a choreography: a formal description of overall behaviour that processes should collaborate to implement, like authenticating a user or purchasing an item online. Formality brings clarity, but not only that. Choreographies can contribute to important safety and liveness properties. This book is an ideal introduction to theory of choreographies for students, researchers, and professionals in computer science and applied mathematics. It covers languages for writing choreographies and their semantics, and principles for implementing choreographies correctly. The text treats the study of choreographies as a discipline in its own right, following a systematic approach that starts from simple foundations and proceeds to more advanced features in incremental steps. Each chapter includes examples and exercises aimed at helping with understanding the theory and its relation to practice."},"conf/ecows/MontesiGZ07":{"pdf":"mgz07","abstract":"Dynamic fault handling is a new approach for dealing with fault management in service-oriented applications. Fault handlers, termination handlers and compensation handlers are installed at execution time instead of being statically defined. In this paper we present this programming style and our implementation of dynamic fault handling in JOLIE, providing finally a nontrivial example of its usage."},"conf/dcai/GabbrielliGM14":{"pdf":"ggm14","abstract":"In Service-Oriented Architectures (SOA), services are composed by coordinating their communications into a flow of interactions. Coloured Petri nets (CPN) offer a formal yet easy tool for modelling interactions in SOAs, however mapping abstract SOAs into executable ones requires a non-trivial and time-costly analysis. Here, we propose a methodology that maps CPN-modelled SOAs into Jolie SOAs (our target language), exploiting a collection of recurring control-flow patterns, called Workflow Patterns, as composable blocks of the translation. We validate our approach with a realistic use case. In addition, we pragmatically asses the expressiveness of Jolie wrt the considered WPs."},"conf/concur/CarboneMS14":{"pdf":"cms14","abstract":"In Choreographic Programming, a distributed system is programmed by giving a choreography, a global description of its interactions, instead of separately specifying the behaviour of each of its processes. Process implementations in terms of a distributed language can then be automatically projected from a choreography. We present Linear Compositional Choreographies (LCC), a proof theory for reasoning about programs that modularly combine choreographies with processes. Using LCC, we logically reconstruct a semantics and a projection procedure for programs. For the first time, we also obtain a procedure for extracting choreographies from process terms."},"journals/corr/abs-2104-02458":{"peerReviewedVersion":"conf\/coordination\/GiallorenzoMPRS21","abstract":"In the field of microservices, Model-Driven Engineering has emerged as a\npowerful methodology for architectural design, and new programming languages\nhave introduced language abstractions to deal with microservice development\nmore effectively. In this article, we present the first preliminary\ninvestigation of how the two approaches can be married, taking the LEMMA\nframework and the Jolie programming language as respective representatives. By\ndeveloping a conceptual metamodel for Jolie, we elicit a strong link between\nthe two approaches, which shows that there is much to gain. We discuss a few\nlow-hanging fruits that come from our finding and present some interesting\nfuture directions that arise from our new viewpoint."},"conf/coordination/CarboneDM14":{"pdf":"cdm14","abstract":"A session-based process satisfies the progress property if its sessions never get stuck when it is executed in an adequate context. Previous work studied how to define progress by introducing the notion of catalysers, execution contexts generated from the type of a process. In this paper, we refine such definition to capture a more intuitive notion of context adequacy for checking progress. Interestingly, our new catalysers lead to a novel characterisation of progress in terms of the standard notion of lock-freedom. Guided by this discovery, we also develop a conservative extension of catalysers that does not depend on types, generalising the notion of progress to untyped session-based processes. We combine our results with existing techniques for lock-freedom, obtaining a new methodology for proving progress. Our methodology captures new processes wrt previous progress analysis based on session types."},"journals/corr/abs-2209-01886":{"abstract":"Choreographic programming is a paradigm for writing coordination plans for\ndistributed systems from a global point of view, from which\ncorrect-by-construction decentralised implementations can be generated\nautomatically.\n  Theory of choreographies typically includes a number of complex results that\nare proved by structural induction. The high number of cases and the subtle\ndetails in some of these proofs has led to important errors being found in\npublished works.\n  In this work, we formalise the theory of a choreographic programming language\nin Coq. Our development includes the basic properties of this language, a proof\nof its Turing completeness, a compilation procedure to a process language, and\nan operational characterisation of the correctness of this procedure.\n  Our formalisation experience illustrates the benefits of using a theorem\nprover: we get both an additional degree of confidence from the mechanised\nproof, and a significant simplification of the underlying theory. Our results\noffer a foundation for the future formal development of choreographic\nlanguages."},"journals/corr/abs-2106-11818":{"abstract":"Initiated by Abramsky [1994], the Proofs as Processes agenda is to establish\na solid foundation for the study of concurrent languages, by researching the\nconnection between linear logic and the $\\pi$-calculus.\n  To date, Proofs as Processes is still a partial success. Caires and Pfenning\n[2010] showed that linear propositions correspond to session types, which\nprescribe the observable behaviour of processes. Further, Carbone et al. [2018]\ndemonstrated that adopting devices from hypersequents [Avron 1991] shapes\nproofs such that they correspond to the expected syntactic structure of\nprocesses in the $\\pi$-calculus. What remains is reconstructing the expected\nmetatheory of session types and the $\\pi$-calculus. In particular, the hallmark\nof session types, session fidelity, still has to be reconstructed: a\ncorrespondence between the observable behaviours of processes and their session\ntypes, in terms of labelled transitions.\n  In this article, we present $\\pi$LL, a new process calculus rooted in linear\nlogic. The key novelty of $\\pi$LL is that it comes with a carefully formulated\ndesign recipe, based on a dialgebraic view of labelled transition systems.\nThanks to our recipe, $\\pi$LL offers the expected transition systems of session\ntypes, which we use to establish session fidelity. We use $\\pi$LL to carry out\nthe first thorough investigation of the metatheoretical properties enforced by\nlinear logic on the observable behaviour of processes, uncovering connections\nwith similarity and bisimilarity. We also prove that $\\pi$LL and our recipe\nform a robust basis for the further exploration of Proofs as Processes, by\nconsidering different features: polymorphism, process mobility, and recursion."},"journals/peerj-cs/GiallorenzoMSZ22":{"pdf":"gmsz22","abstract":"<jats:p>The adoption of edge and fog systems, along with the introduction of privacy-preserving regulations, compel the usage of tools for expressing complex data queries in an ephemeral way. That is, queried data should not persist. Database engines partially address this need, as they provide domain-specific languages for querying data. Unfortunately, using a database in an ephemeral setting has inessential issues related to throughput bottlenecks, scalability, dependency management, and security (<jats:italic>e.g.<\/jats:italic>, query injection). Moreover, databases can impose specific data structures and data formats, which can hinder the development of microservice architectures that integrate heterogeneous systems and handle semi-structured data. In this article, we present Jolie\/Tquery, the first query framework designed for ephemeral data handling in microservices. Jolie\/Tquery joins the benefits of a technology-agnostic, microservice-oriented programming language, Jolie, and of one of the most widely-used query languages for semi-structured data in microservices, the MongoDB aggregation framework. To make Jolie\/Tquery reliable for the users, we follow a cleanroom software engineering process. First, we define Tquery, a theory for querying semi-structured data compatible with Jolie and inspired by a consistent variant of the key operators of the MongoDB aggregation framework. Then, we describe how we implemented Jolie\/Tquery following Tquery and how the Jolie type system naturally captures the syntax of Tquery and helps to preserve its invariants. To both illustrate Tquery and Jolie\/Tquery, we present the use case of a medical algorithm and build our way to a microservice that implements it using Jolie\/Tquery. Finally, we report microbenchmarks that validate the expectation that, in the ephemeral case, using Jolie\/Tquery outperforms using an external database (MongoDB, specifically).<\/jats:p>"},"conf/esocc/2022":{"path":"proceedings-esocc-2022","abstract":"Proceedings of the 9th IFIP WG 6.12 European Conference on Service-Oriented and Cloud Computing (ESOCC)."},"conf/IEEEscc/MontesiPP21":{"pdf":"mpp21","abstract":"We propose Sliceable Monolith, a new methodology for developing microservice architectures and perform their integration testing by leveraging most of the simplicity of a monolith: a single codebase and a local execution environment that simulates distribution. Then, a tool compiles a codebase for each microservice and a cloud deployment configuration. The key enabler of our approach is the technology-agnostic service definition language offered by Jolie."},"journals/corr/abs-1711-10201":{"peerReviewedVersion":"conf\/sac\/Cruz-FilipeMP18","abstract":"Choreographic Programming is a paradigm for developing\ncorrect-by-construction concurrent programs, by writing high-level descriptions\nof the desired communications and then synthesising process implementations\nautomatically. So far, choreographic programming has been explored in the\nmonadic setting: interaction terms express point-to-point communications of a\nsingle value. However, real-world systems often rely on interactions of\npolyadic nature, where multiple values are communicated among two or more\nparties, like multicast, scatter-gather, and atomic exchanges. We introduce a\nnew model for choreographic programming equipped with a primitive for grouped\ninteractions that subsumes all the above scenarios. Intuitively, grouped\ninteractions can be thought of as being carried out as one single interaction.\nIn practice, they are implemented by processes that carry them out in a\nconcurrent fashion. After formalising the intuitive semantics of grouped\ninteractions, we prove that choreographic programs and their implementations\nare correct and deadlock-free by construction."},"M13:phd":{"abstract":"<p>Choreographies are descriptions of distributed systems where the developer gives a global view of how messages are exchanged by endpoint nodes (endpoints for short), instead of separately defining the behaviour of each endpoint. They have a significant impact on the quality of software, as they offer a concise view of the message flows enacted by a system. For this reason, in the last decade choreographies have been employed in the development of programming languages, giving rise to a programming paradigm that in this dissertation we refer to as Choreographic Programming.<\/p><p>Recent formal investigations of choreographies show that they have potential as foundations for the development of safe distributed software. The key idea is that since choreographies abstract from the single input\/output actions of endpoints, they avoid typical safety problems such as deadlocks and race conditions; the concrete implementation of each endpoint described in a choreography can then be automatically obtained by compilation, ensuring that such implementations are also safe by construction from the originating choreography. However, current formal models for choreographies do not deal with critical aspects of distributed programming, such as asynchrony, mobility, modularity, and multiparty sessions; it remains thus unclear whether choreographies can still guarantee safety when dealing with such nontrivial features.<\/p><p>This PhD dissertation argues for the usefulness of choreographic programming as a paradigm for the development of safe distributed systems. We proceed by investigating its foundations and application. To this aim we provide three main contributions.<\/p><p>The first contribution is the development of a formal model and type theory for choreographic programming that support asynchrony, mobility, modular development, and multiparty sessions. We prove that our model guarantees safety by mapping choreographies to distributed implementations in terms of a variant of the π-calculus, the reference model for mobile processes. Our translation preserves the expected safety properties of choreographies, among which freedom from deadlocks and race conditions.<\/p><p>The second contribution is the development of Linear Connection Logic (LCL), a formal logic that captures the reasoning behind choreographic programming. We show that LCL is a conservative extension of Linear Logic. We then develop a Curry-Howard correspondence between LCL and a calculus of choreographies, proving that: (i) proofs in LCL correspond to choreographies; and (ii) the transformations between proofs in LCL to proofs in Linear Logic and vice versa correspond to compiling choreography programs to π-calculus terms and vice versa. The latter result, known as round-trip development, contributes to the open problem of extracting choreographies from existing endpoint programs.<\/p><p>The third contribution is the implementation of a prototype programming framework for choreographic programming, called Chor. Chor provides an Integrated Development Environment (IDE) for programming with choreographies, equipped with a type checker for verifying that choreographies respect protocol specifications given as session types. Programs in Chor can be compiled to executable endpoint implementation in the Jolie programming language, a general-purpose language for distributed computing, which we extend to support the development of multiparty asynchronous sessions. We use Chor for evaluating choreographic programming against a series of use cases.<\/p>"},"journals/corr/abs-1910-11741":{"path":"implementing-choreography-extraction-impl-only-arxiv","abstract":"Choreography extraction deals with the generation of a choreography (a global\ndescription of communication behaviour) from a set of local process behaviours.\nIn this work, we implement a previously proposed theory for extraction and show\nthat, in spite of its theoretical exponential complexity, it is usable in\npractice. We discuss the data structures needed for an efficient\nimplementation, introduce some optimizations, and perform a systematic\npractical evaluation."},"conf/coordination/Cruz-FilipeGMP23":{"pdf":"cgmp23","abstract":"<p>Choreographic programming is a paradigm where a concurrent or distributed system is developed in a top-down fashion. Programs, called choreographies, detail the desired interactions between processes, and can be compiled to distributed implementations based on message passing. Choreographic languages usually guarantee deadlock-freedom and provide an operational correspondence between choreographies and their compiled implementations, but until now little work has been done on verifying other properties.<\/p><p>This paper presents a Hoare-style logic for reasoning about the behaviour of choreographies, and illustrate its usage in representative examples. We show that this logic is sound and complete, and discuss decidability of its judgements. Using existing results from choreographic programming, we show that any functional correctness property proven for a choreography also holds for its compiled implementation.<\/p>"},"conf/forte/Cruz-FilipeM16":{"pdf":"cm16_forte","abstract":"<p>Choreographic Programming is a development methodology for concurrent software that guarantees correctness by construction. The key to this paradigm is to disallow mismatched I\/O operations in programs, called choreographies, and then mechanically synthesise distributed implementations in terms of standard process models via a mechanism known as EndPoint Projection (EPP).<\/p><p>Despite the promise of choreographic programming, there is still a lack of practical evaluations that illustrate the applicability of choreographies to concrete computational problems with standard concurrent solutions. In this work, we explore the potential of choreographies by using Procedural Choreographies (PC), a model that we recently proposed, to write distributed algorithms for sorting (Quicksort), solving linear equations (Gaussian elimination), and computing Fast Fourier Transform. We discuss the lessons learned from this experiment, giving possible directions for the usage and future improvements of choreography languages.<\/p>"},"conf/forte/Cruz-FilipeM17":{"pdf":"cm17-forte","abstract":"Choreographic Programming is an emerging paradigm for correct-by-construction concurrent programming. However, its applicability is limited by the current lack of support for reusable procedures. We propose Procedural Choreographies (PC), a choreographic language model with full procedural abstraction. PC includes unbounded process creation and name mobility, yielding a powerful framework for writing correct concurrent algorithms that can be compiled into a process calculus. This increased expressivity requires a typing discipline to ensure that processes are properly connected when enacting procedures."},"conf/dais/MontesiT17":{"pdf":"mt17-forte","abstract":"We describe a first proposal for a new packaging system for microservices based on the Jolie programming language, called the Jolie Package Manager (JPM). Its main features revolve around service interfaces, which make the functionalities that a service provides and depends on explicit. For the first time, JPM supports binding a service to an externally-provided package, and a notion of interface parametricity that can be used to develop generic service libraries that can modify the behaviour of arbitrary services. We illustrate the latter with a generic circuit breaker package."},"journals/scp/LaneseMM15":{"abstract":"Special issue on Service-Oriented Architecture and Programming (SOAP 2013)."},"journals/corr/abs-1904-06848":{"pdf":"kmp18","abstract":"Process calculi based on logic, such as $\\pi$DILL and CP, provide a\nfoundation for deadlock-free concurrent programming. However, in previous work,\nthere is a mismatch between the rules for constructing proofs and the term\nconstructors of the $\\pi$-calculus: the fundamental operator for parallel\ncomposition does not correspond to any rule of linear logic. Kokke et al.\n(2019) introduced Hypersequent Classical Processes (HCP), which addresses this\nmismatch using hypersequents (collections of sequents) to register parallelism\nin the typing judgements. However, the step from CP to HCP is a big one. As of\nyet, HCP does not have reduction semantics, and the addition of delayed actions\nmeans that CP processes interpreted as HCP processes do not behave as they\nwould in CP. We introduce HCP-, a variant of HCP with reduction semantics and\nwithout delayed actions. We prove progress, preservation, and termination, and\nshow that HCP- supports the same communication protocols as CP."},"journals/dc/CarboneMS18":{"path":"choreographies-logically-journal","pdf":"cms18","abstract":"<p>In Choreographic Programming, a distributed system is programmed by giving a choreography, a global description of its interactions, instead of separately specifying the behaviour of each of its processes. Process implementations in terms of a distributed language can then be automatically projected from a choreography.<\/p><p>We present Linear Compositional Choreographies (LCC), a proof theory for reasoning about programs that modularly combine choreographies with processes. Using LCC, we logically reconstruct a semantics and a projection procedure for programs. For the first time, we also obtain a procedure for extracting choreographies from process terms.<\/p>"},"conf/isola/LaneseM10":{"path":"error-handling-from-theory-to-practice","pdf":"lm10","abstract":"We describe the different issues that a language designer has to tackle when defining error handling mechanisms for service-oriented computing. We first discuss the issues that have to be considered when developing error handling mechanisms inside a process calculus, i.e. an abstract model. We then analyze how these issues change when moving from a process calculus to a full-fledged language based on it. We consider as an example the language Jolie, and the calculus SOCK it is based upon."},"journals/corr/abs-2304-14539":{"peerReviewedVersion":"conf\/coordination\/Cruz-FilipeGMP23","abstract":"Choreographic programming is a paradigm where a concurrent or distributed\nsystem is developed in a top-down fashion. Programs, called choreographies,\ndetail the desired interactions between processes, and can be compiled to\ndistributed implementations based on message passing. Choreographic languages\nusually guarantee deadlock-freedom and provide an operational correspondence\nbetween choreographies and their compiled implementations, but until now little\nwork has been done on verifying other properties.\n  This paper presents a Hoare-style logic for reasoning about the behaviour of\nchoreographies, and illustrate its usage in representative examples. We show\nthat this logic is sound and complete, and discuss decidability of its\njudgements. Using existing results from choreographic programming, we show that\nany functional correctness property proven for a choreography also holds for\nits compiled implementation."},"journals/corr/GuidiLMM17":{"path":"microservices-a-language-based-approach-arxiv","peerReviewedVersion":"books\/sp\/17\/GuidiLMM17","abstract":"Microservices is an emerging development paradigm where software is obtained\nby composing autonomous entities, called (micro)services. However, microservice\nsystems are currently developed using general-purpose programming languages\nthat do not provide dedicated abstractions for service composition. Instead,\ncurrent practice is focused on the deployment aspects of microservices, in\nparticular by using containerization. In this chapter, we make the case for a\nlanguage-based approach to the engineering of microservice architectures, which\nwe believe is complementary to current practice. We discuss the approach in\ngeneral, and then we instantiate it in terms of the Jolie programming language."},"conf/forte/Montesi17":{"pdf":"m17_forte","abstract":"Classical Processes (CP) is a calculus where the proof theory of classical linear logic types processes `a la π-calculus, building on a Curry-Howard correspondence between session types and linear propositions. We contribute to this research line by extending CP with process mobility, inspired by the Higher-Order π-calculus. The key to our calculus is that sequents are asymmetric: one side types sessions as in CP and the other types process variables, which can be instantiated with process values. The controlled interaction between the two sides ensures that process variables can be used at will, but always respecting the linear usage of sessions expected by the environment."},"conf/lpar/Cruz-FilipeMR23":{"pdf":"cmr23","abstract":"<jats:p>Choreographic programming is a paradigm where programmers write global descrip- tions of distributed protocols, called choreographies, and correct implementations are au- tomatically generated by a mechanism called projection. Not all choreographies are pro- jectable, because decisions made by one process must be communicated to other processes whose behaviour depends on them \u2013 a property known as knowledge of choice.<\/jats:p><jats:p>The standard formulation of knowledge of choice disallows protocols such as third-party authentication with retries, where two processes iteratively interact, and other processes wait to be notified at the end of this loop. In this work we show how knowledge of choice can be weakened, extending the class of projectable choreographies with these and other interesting behaviours. The whole development is formalised in Coq. Working with a proof assistant was crucial to our development, because of the help it provided with detecting counterintuitive edge cases that would otherwise have gone unnoticed.<\/jats:p>"},"conf/soca/PredaGGMM12":{"pdf":"dggmm12","abstract":"In the context of Service-Oriented Architectures (SOAs), the integration of services is an important aspect that is usually addressed by using specific tools, such as Enterprise Service Bus (ESB). In this paper we propose a frameworkto perform service integration building on the extension of service interfaces, capturing a class of service integrators that are decoupled from the services they integrate in an SOA. We show how our service integrators can be used in practice by evaluating our approach with Jolie, a serviceoriented programming language. Finally, we present how our methodology differs from the standard practice with ESB."},"journals/corr/abs-1808-05088":{"peerReviewedVersion":"conf\/lopstr\/CarboneCMM18","abstract":"We present Multiparty Classical Choreographies (MCC), a language model where\nglobal descriptions of communicating systems (choreographies) implement typed\nmultiparty sessions. Typing is achieved by generalising classical linear logic\nto judgements that explicitly record parallelism by means of hypersequents. Our\napproach unifies different lines of work on choreographies and processes with\nmultiparty sessions, as well as their connection to linear logic. Thus, results\ndeveloped in one context are carried over to the others. Key novelties of MCC\ninclude support for server invocation in choreographies, as well as\nlogic-driven compilation of choreographies with replicated processes."},"conf/coordination/MauroGGM11":{"pdf":"mggm11","abstract":"<p>A fundamental aspect which affects the efficiency and the performance of Service-Oriented Architectures is the mechanism which allows to manage sessions and, in particular, to assign incoming messages to the correct sessions (also known as service instances). A relevant mechanism for solving this problem, first introduced by BPEL and then used in other languages (e.g. Jolie) is that one based on correlation sets. The BPEL and Jolie languages are currently allowing the use of messages whose target is only one session. However there are a lot of scenarios where being able to send a broadcast message to more than one session could be useful. Supporting such a broadcast primitive means to allow correlation sets which can contain unspecified variables and this can be very inefficient, since usual implementations in terms of hash tables cannot be used in this case.<\/p><p>In this paper we propose a data structure, based on radix trees and an algorithm for managing a correlation mechanism that supports the broadcast primitive, without degrading the performances.<\/p>"},"conf/facs2/Cruz-FilipeM16":{"pdf":"cm16_facs","abstract":"<p>Choreographic Programming is a paradigm for developing concurrent programs that are deadlock-free by construction, by programming communications declaratively and then synthesising process implementations automatically. Despite strong interest on choreographies, a foundational model that explains which computations can be performed with the hallmark constructs of choreographies is still missing.<\/p><p>In this work, we introduce Core Choreographies (CC), a model that includes only the core primitives of choreographic programming. Every computable function can be implemented as a choreography in CC, from which we can synthesise a process implementation where independent computations run in parallel. We discuss the design of CC and argue that it constitutes a canonical model for choreographic programming.<\/p>"},"journals/pacmpl/KokkeMP19":{"pdf":"kmp19","abstract":"<jats:p>We present Hypersequent Classical Processes (HCP), a revised interpretation of the \u201CProofs as Processes\u201D correspondence between linear logic and the π-calculus initially proposed by Abramsky [1994], and later developed by Bellin and Scott [1994], Caires and Pfenning [2010], and Wadler [2014], among others. HCP mends the discrepancies between linear logic and the syntax and observable semantics of parallel composition in the π-calculus, by conservatively extending linear logic to hyperenvironments (collections of environments, inspired by the hypersequents by Avron [1991]). Separation of environments in hyperenvironments is internalised by ⊗ and corresponds to parallel process behaviour. Thanks to this property, for the first time we are able to extract a labelled transition system (lts) semantics from proof rewritings. Leveraging the information on parallelism at the level of types, we obtain a logical reconstruction of the delayed actions that Merro and Sangiorgi [2004] formulated to model non-blocking I\/O in the π-calculus. We define a denotational semantics for processes based on Brzozowski derivatives, and uncover that non-interference in HCP corresponds to Fubini\u2019s theorem of double antiderivation. Having an lts allows us to validate HCP using the standard toolbox of behavioural theory. We instantiate bisimilarity and barbed congruence for HCP, and obtain a full abstraction result: bisimilarity, denotational equivalence, and barbed congruence coincide.<\/jats:p>"},"journals/corr/SafinaMM15":{"peerReviewedVersion":"conf\/aina\/SafinaMMR16","pdf":"smm15","abstract":"Microservices is an architectural style inspired by service-oriented\ncomputing that has recently started gaining popularity. Jolie is a programming\nlanguage based on the microservices paradigm: the main building block of Jolie\nsystems are services, in contrast to, e.g., functions or objects. The\nprimitives offered by the Jolie language elicit many of the recurring patterns\nfound in microservices, like load balancers and structured processes. However,\nJolie still lacks some useful constructs for dealing with message types and\ndata manipulation that are present in service-oriented computing. In this\npaper, we focus on the possibility of expressing choices at the level of data\ntypes, a feature well represented in standards for Web Services, e.g., WSDL. We\nextend Jolie to support such type choices and show the impact of our\nimplementation on some of the typical scenarios found in microservice systems.\nThis shows how computation can move from a process-driven to a data-driven\napproach, and leads to the preliminary identification of recurring\ncommunication patterns that can be shaped as design patterns."},"journals/corr/Cruz-FilipeM15":{"peerReviewedVersion":"journals\/tcs\/Cruz-FilipeM20","pdf":"cm15","abstract":"Choreographic Programming is a programming paradigm for building concurrent\nprograms that are deadlock-free by construction, as a result of programming\ncommunications declaratively and then synthesising process implementations\nautomatically. Despite strong interest on choreographies, a foundational model\nthat explains which computations can be performed with the hallmark constructs\nof choreographies is still missing.\n  In this work, we introduce Core Choreographies (CC), a model that includes\nonly the core primitives of choreographic programming. Every computable\nfunction can be implemented as a choreography in CC, from which we can\nsynthesise a process implementation where independent computations run in\nparallel. We discuss the design of CC and argue that it constitutes a canonical\nmodel for choreographic programming."},"conf/acsd/GuidiLMZ08":{"pdf":"glmz08","abstract":"Service Oriented Computing (SOC) allows for the composition of services which communicate using unidirectional notification or bidirectional request-response primitives. Most service orchestration languages proposed so far provide also primitives to handle faults and compensations. The interplay between fault handling and request-response invocations is nontrivial since, for instance, faults should be notified to the requestresponse communication partners in order to compensate also the remote activities. Our work is motivated by the difficulties encountered in programming, using current orchestration languages, some fault handling strategies. We propose as a solution an orchestration programming style in which fault and compensation handlers are dynamically installed. We show the adequacy of our proposal defining its semantics, and proving that it satisfies some expected high-level properties. Finally, we also show how to apply dynamic handler installation in a nontrivial automotive scenario."},"conf/icsoc/MontesiC11":{"pdf":"mc11","abstract":"Correlation sets define a powerful mechanism for routing incoming communications to the correct running session within a server, by inspecting the content of the received messages. We present a language for programming services based on correlation sets taking into account key aspects of service-oriented systems, such as distribution, loose coupling, open-endedness and integration. Distinguishing features of our approach are the notion of correlation aliases and an asynchronous communication model. Our language is equipped with formal syntax, semantics, and a typing system for ensuring desirable properties of programs with respect to correlation sets. We provide an implementation as an extension of the JOLIE language and apply it to a nontrivial real-world example of a fully-functional distributed user authentication system."},"books/sp/wsf14/MontesiGZ14":{"pdf":"mgz14","abstract":"<p>The wide adoption of service-oriented computing has led to a heterogeneous scenario formed by different technologies and specifications. Examples can be found both at the design level \u2014 the frameworks for defining services and those for defining their coordination feature fundamentally different primitives \u2014 and at the implementation level \u2014 different communication technologies are used depending on the context.<\/p><p>In this chapter we present Jolie, a fully-fledged service-oriented programming language. Jolie addresses the aforementioned heterogeneity in two ways. On the one hand, it combines computation and composition primitives in an intuitive and concise syntax. On the other hand, the behaviour and deployment of a Jolie program are orthogonal: they can be independently defined and recombined as long as they have compatible typing.<\/p>"},"conf/sac/Cruz-FilipeMP18":{"pdf":"cmp18","abstract":"<p>Choreographic Programming is a paradigm for developing correctby-construction concurrent programs, by writing high-level descriptions of the desired communications and then synthesising process implementations automatically. So far, choreographic programming has been explored in the monadic setting: interaction terms express point-to-point communications of a single value. However, realworld systems often rely on interactions of polyadic nature, where multiple values are communicated among two or more parties, like multicast, scatter-gather, and atomic exchanges.<\/p><p>We introduce a new model for choreographic programming equipped with a primitive for grouped interactions that subsumes all the above scenarios. Intuitively, grouped interactions can be thought of as being carried out as one single interaction. In practice, they are implemented by processes that carry them out in a concurrent fashion. After formalising the intuitive semantics of grouped interactions, we prove that choreographic programs and their implementations are correct and deadlock-free by construction.<\/p>"},"journals/corr/Cruz-FilipeM16":{"peerReviewedVersion":"conf\/forte\/Cruz-FilipeM17","abstract":"A recent study of bugs in real-world concurrent and distributed systems found\nthat, while implementations of individual protocols tend to be robust, the\ncomposition of multiple protocols and its interplay with internal computation\nis the culprit for most errors. Multiparty Session Types and Choreographic\nProgramming are methodologies for developing correct-by-construction concurrent\nand distributed software, based on global descriptions of communication flows.\nHowever, protocol composition is either limited or left unchecked. Inspired by\nthese two methodologies, in this work we present a new language model for the\nsafe composition of protocols, called Procedural Choreographies (PC). Protocols\nin PC are procedures, parameterised on the processes that enact them.\nProcedures define communications declaratively using global descriptions, and\nprograms are written by invoking and composing these procedures. An\nimplementation in terms of a process model is then mechanically synthesised,\nguaranteeing correctness and deadlock-freedom. We study PC in the settings of\nsynchronous and asynchronous communications, and illustrate its expressivity\nwith some representative examples."},"conf/sac/Montesi13":{"notes":{"text":"<award>Best Poster Award<\/award>"},"pdf":"m13","abstract":"We present a programming framework, based upon the Jolie language, for the native modelling of process-aware web information systems. Our major contribution is to offer a unifying approach for the programming of distributed architectures based on HTTP that support typical features of the process-oriented paradigm, such as structured communication flows and multiparty sessions."},"journals/corr/abs-1904-11327":{"abstract":"In modern application areas for software systems --- like eHealth, the\nInternet-of-Things, and Edge Computing --- data is encoded in heterogeneous,\ntree-shaped data-formats, it must be processed in real-time, and it must be\nephemeral, i.e., not persist in the system. While it is preferable to use a\nquery language to express complex data-handling logic, their typical execution\nengine, a database external from the main application, is unfit in scenarios of\nephemeral data-handling. A better option is represented by integrated query\nframeworks, which benefit from existing development support tools (e.g., syntax\nand type checkers) and execute within the application memory. In this paper, we\npropose one such framework that, for the first time, targets tree-shaped,\ndocument-oriented queries. We formalise an instantiation of MQuery, a sound\nvariant of the widely-used MongoDB query language, which we implemented in the\nJolie language. Jolie programs are microservices, the building blocks of modern\nsoftware systems. Moreover, since Jolie supports native tree data-structures\nand automatic management of heterogeneous data-encodings, we can provide a\nuniform way to use MQuery on any data-format supported by the language. We\npresent a non-trivial use case from eHealth, use it to concretely evaluate our\nmodel, and to illustrate our formalism."},"journals/scp/Montesi16":{"path":"process-aware-web-programming-with-jolie-journal","pdf":"m16","abstract":"We extend the Jolie programming language to capture the native modelling of processaware web information systems, i.e., web information systems based upon the execution of business processes. Our main contribution is to offer a unifying approach for the programming of distributed architectures on the web, which can capture web servers, stateful process execution, and the composition of services via mediation. We discuss applications of this approach through a series of examples that cover, e.g., static content serving, multiparty sessions, and the evolution of web systems. Finally, we present a performance evaluation that includes a comparison of Jolie-based web systems to other frameworks and a measurement of its scalability"},"journals/corr/abs-1302-6331":{"pdf":"mc11","abstract":"Choreography-based programming is a powerful paradigm for defining\ncommunication-based systems from a global viewpoint. A choreography can be\nchecked against multiparty protocol specifications, given as behavioural types,\nthat may be instantiated indefinitely at runtime. Each protocol instance is\nstarted with a synchronisation among the involved peers.\n  We analyse a simple transformation from a choreography with a possibly\nunbounded number of protocol instantiations to a choreography instantiating a\nsingle protocol, which is the merge of the original ones. This gives an\neffective methodology for obtaining new protocols by composing existing ones.\nMoreover, by removing all synchronisations required for starting protocol\ninstances, our transformation reduces the number of communications and\nresources needed to execute a choreography."},"conf/coordination/GabbrielliGLMPZ19":{"pdf":"gglmpz19","abstract":"<p>Serverless computing, also known as Functions-as-a-Service, is a recent paradigm aimed at simplifying the programming of cloud applications. The idea is that developers design applications in terms of functions, which are then deployed on a cloud infrastructure. The infrastructure takes care of executing the functions whenever requested by remote clients, dealing automatically with distribution and scaling with respect to inbound traffic.<\/p><p>While vendors already support a variety of programming languages for serverless computing (e.g. Go, Java, Javascript, Python), as far as we know there is no reference model yet to formally reason on this paradigm. In this paper, we propose the first core formal programming model for serverless computing, which combines ideas from both the λ-calculus (for functions) and the π-calculus (for communication). To illustrate our proposal, we model a real-world serverless system. Thanks to our model, we capture limitations of current vendors and formalise possible amendments.<\/p>"},"journals/corr/abs-1711-08700":{"abstract":"Choreographies are widely used for the specification of concurrent and\ndistributed software architectures. Since asynchronous communications are\nubiquitous in real-world systems, previous works have proposed different\napproaches for the formal modelling of asynchrony in choreographies. Such\napproaches typically rely on ad-hoc syntactic terms or semantics for capturing\nthe concept of messages in transit, yielding different formalisms that have to\nbe studied separately.\n  In this work, we take a different approach, and show that such extensions are\nnot needed to reason about asynchronous communications in choreographies.\nRather, we demonstrate how a standard choreography calculus already has all the\nneeded expressive power to encode messages in transit (and thus asynchronous\ncommunications) through the primitives of process spawning and name mobility.\nThe practical consequence of our results is that we can reason about real-world\nsystems within a choreography formalism that is simpler than those hitherto\nproposed."},"journals/corr/abs-1712-05465":{"abstract":"Choreographies are global descriptions of communication structures, inspired\nby the \"Alice and Bob\" notation of security protocols. They have been\nsuccessfully employed in the design and implementation of distributed systems.\nHowever, there is still limited evidence of the applicability of choreographies\nin the real-world setting of distributed programming, where communication\nactions may fail. In this work, we propose the first choreography model that\nallows for communication failures and the programming of user-defined code to\ndeal with such failures. We validate our model by implementing common\nstrategies for handling communication failures in a robust way, which in turn\ncan be used as a library by choreographies that assume reliable communication.\nWe equip our model with a typing discipline that can statically verify\nreliability properties, in particular at-most-once and exactly-once delivery.\nWe demonstrate the applicability of our model by defining a\nsemantics-preserving compilation procedure towards a process calculus equipped\nwith unreliable I\/O actions."},"conf/ecoop/GiallorenzoMPRS21":{"notes":{"text":"<award>Distinguished Paper Award<\/award>"},"pdf":"gmprsw21","abstract":"<p>Choreographic languages aim to express multiparty communication protocols, by providing primitives that make interaction manifest. Multitier languages enable programming computation that spans across several tiers of a distributed system, by supporting primitives that allow computation to change the location of execution. Rooted into different theoretical underpinnings\u2014respectively process calculi and lambda calculus\u2014the two paradigms have been investigated independently by different research communities with little or no contact. As a result, the link between the two paradigms has remained hidden for long.<\/p><p>In this paper, we show that choreographic languages and multitier languages are surprisingly similar. We substantiate our claim by isolating the core abstractions that differentiate the two approaches and by providing algorithms that translate one into the other in a straightforward way. We believe that this work paves the way for joint research and cross-fertilisation among the two communities.<\/p>"},"conf/coordination/GiallorenzoMPR22":{"pdf":"gmpr22","abstract":"We introduce LEMMA2Jolie, a tool for translating domain models of microservice architectures given in LEMMA into concrete APIs of microservices in the Jolie programming language. Our tool combines the state of the art for the design and implementation of microservices: developers can use Domain-Driven Design (DDD) for the construction of the domain models of a microservice architecture, and then automatically transition to a serviceoriented programming language that provides native linguistic support for implementing the behaviour of each microservice."},"conf/esocc/PredaGGMM12":{"pdf":"dggmm12b","abstract":"<p>Service-oriented architectures (SOAs) usually comprehend in-the-middle entities such as proxies or service mediators that compose services abstracting from the order in which they exchange messages. Although widely used, these entities are usually implemented by means of ad-hoc solutions.<\/p><p>In this paper we generalise this composition mechanism by identifying the primitive notion of aggregation. We formally define the semantics of aggregation in terms of a process calculus. We also provide a reference implementation for this primitive by extending the Jolie language, thus allowing for the experimentation with real SOA scenarios.<\/p>"},"books/sp/17/GuidiLMM17":{"path":"microservices-a-language-based-approach","pdf":"glmm17","abstract":"Microservices is an emerging development paradigm where software is obtained by composing autonomous entities, called (micro)services. However, microservice systems are currently developed using general-purpose programming languages that do not provide dedicated abstractions for service composition. Instead, current practice is focused on the deployment aspects of microservices, in particular by using containerization. In this chapter, we make the case for a languagebased approach to the engineering of microservice architectures, which we believe is complementary to current practice. We discuss the approach in general, and then we instantiate it in terms of the Jolie programming language."},"journals/corr/abs-1802-02917":{"abstract":"Classical Processes (CP) is a calculus where the proof theory of classical\nlinear logic types communicating processes with mobile channels, a la\npi-calculus. Its construction builds on a recent propositions as types\ncorrespondence between session types and propositions in linear logic.\nDesirable properties such as type preservation under reductions and progress\ncome for free from the metatheory of linear logic.\n  We contribute to this research line by extending CP with code mobility. We\ngeneralise classical linear logic to capture higher-order (linear) reasoning on\nproofs, which yields a logical reconstruction of (a variant of) the\nHigher-Order pi-calculus (HOpi). The resulting calculus is called Classical\nHigher-Order Processes (CHOP). We explore the metatheory of CHOP, proving that\nits semantics enjoys type preservation and progress (terms do not get stuck).\nWe also illustrate the expressivity of CHOP through examples, derivable syntax\nsugar, and an extension to multiparty sessions. Lastly, we define a translation\nfrom CHOP to CP, which encodes mobility of process code into reference passing."},"conf/coordination/GiallorenzoMPRU23":{"notes":{"text":"<award>Best Artefact Award<\/award>"},"pdf":"gmpru23","abstract":"We present JoT, a testing framework for Microservice Architectures (MSAs) based on technology agnosticism, a core principle of microservices. The main advantage of JoT is that it reduces the amount of work for a) testing for MSAs whose services use different technology stacks, b) writing tests that involve multiple services, and c) reusing tests of the same MSA under different deployment configurations or after changing some of its components (e.g., when, for performance, one reimplements a service with a different technology). In JoT, tests are orchestrators that can both consume or offer operations from\/to the MSA under test. The language for writing JoT tests is Jolie, which provides constructs that support technology agnosticism and the definition of terse test behaviours. We present the methodology we envision for testing MSAs with JoT and we validate it by implementing non-trivial test scenario"},"conf/IEEEscc/GiallorenzoMSZ19":{"pdf":"gmsz19","abstract":"Ephemeral data handling, whereby processed data do not persist, is an emerging requirement of connected IT systems, due to storage constraints (IoT) or regulatory demands (eHealth, GDPR). We present ongoing work on TQuery, a query language for ephemeral data handling in microservices."},"journals/fuin/GuidiLMZ09":{"pdf":"glmz09","abstract":"Service Oriented Computing (SOC) allows for the composition of services which communicate using unidirectional one-way or bidirectional request-response communication patterns. Most service orchestration languages proposed so far provide also primitives for error handling based on fault, termination, and compensation handlers. Our work is motivated by the difficulties encountered in programming some error handling strategies using current error handling primitives. We propose as a solution an orchestration programming style in which handlers are dynamically installed. We assess our proposal by formalizing our approach as an extension of the process calculus SOCK and by proving that our formalization satisfies some expected high-level properties."},"conf/ecows/MontesiGLZ08":{"pdf":"mglz08","abstract":"Dynamic fault handling is a new approach for dealing with fault management in service-oriented applications. Fault handlers, termination handlers and compensation handlers are installed at execution time instead of being statically defined. In this paper we present this programming style and our implementation of dynamic fault handling in JOLIE, providing finally a nontrivial example of its usage."},"journals/corr/abs-1803-01049":{"abstract":"We introduce the calculus of Classical Transitions (CT), which extends the\nresearch line on the relationship between linear logic and processes to\nlabelled transitions. The key twist from previous work is registering\nparallelism in typing judgements, by generalising linear logic judgements from\none sequents to many (hypersequents). This allows us to bridge the gap between\nthe structures of operators used as proof terms in previous work and those of\nthe standard {\\pi}-calculus (in particular parallel operator and restriction).\nThe proof theory of CT allows for new proof transformations, which we show\ncorrespond to a labelled transition system (LTS) for processes. We prove that\nCT enjoys subject reduction and progress."},"journals/corr/abs-2102-02627":{"peerReviewedVersion":"conf\/itp\/Cruz-FilipeMP21","abstract":"Theory of choreographic languages typically includes a number of complex\nresults that are proved by structural induction. The high number of cases and\nthe subtle details in some of them lead to long reviewing processes, and\noccasionally to errors being found in published proofs. In this work, we take a\npublished proof of Turing completeness of a choreographic language and\nformalise it in Coq. Our development includes formalising the choreographic\nlanguage and its basic properties, Kleene's theory of partial recursive\nfunctions, the encoding of these functions as choreographies, and proving this\nencoding correct.\n  With this effort, we show that theorem proving can be a very useful tool in\nthe field of choreographic languages: besides the added degree of confidence\nthat we get from a mechanised proof, the formalisation process led us to a\nsignificant simplification of the underlying theory. Our results offer a\nfoundation for the future formal development of choreographic languages."},"journals/corr/abs-2102-10698":{"peerReviewedVersion":"conf\/ictac\/Cruz-FilipeMP21","abstract":"Choreographic programming is a paradigm for developing concurrent and\ndistributed systems, where programs are choreographies that define, from a\nglobal viewpoint, the computations and interactions that communicating\nprocesses should enact. Choreography compilation translates choreographies into\nthe local definitions of process behaviours, given as terms in a process\ncalculus.\n  Proving choreography compilation correct is challenging and error-prone,\nbecause it requires relating languages in different paradigms (global\ninteractions vs local actions) and dealing with a combinatorial explosion of\nproof cases. We present the first certified program for choreography\ncompilation for a nontrivial choreographic language supporting recursion."},"journals/corr/Montesi14":{"peerReviewedVersion":"journals\/scp\/Montesi16","pdf":"m14","abstract":"We extend the Jolie programming language to capture the native modelling of\nprocess-aware web information systems, i.e., web information systems based upon\nthe execution of business processes. Our main contribution is to offer a\nunifying approach for the programming of distributed architectures on the web,\nwhich can capture web servers, stateful process execution, and the composition\nof services via mediation. We discuss applications of this approach through a\nseries of examples that cover, e.g., static content serving, multiparty\nsessions, and the evolution of web systems. Finally, we present a performance\nevaluation that includes a comparison of Jolie-based web systems to other\nframeworks and a measurement of its scalability."},"journals/corr/abs-2103-09518":{"peerReviewedVersion":"conf\/IEEEscc\/MontesiPP21","abstract":"We propose Sliceable Monolith, a new methodology for developing microservice\narchitectures and perform their integration testing by leveraging most of the\nsimplicity of a monolith: a single codebase and a local execution environment\nthat simulates distribution. Then, a tool compiles a codebase for each\nmicroservice and a cloud deployment configuration. The key enabler of our\napproach is the technology-agnostic service definition language offered by\nJolie."},"journals/corr/Montesi15":{"peerReviewedVersion":"conf\/wsfm\/Montesi15","pdf":"m15","abstract":"We present an overview of some recent efforts aimed at the development of\nChoreographic Programming, a programming paradigm for the production of\nconcurrent software that is guaranteed to be correct by construction from\nglobal descriptions of communication behaviour."},"journals/corr/abs-2303-03972":{"peerReviewedVersion":"conf\/forte\/Cruz-FilipeLM23","pdf":"clm23-arxiv","abstract":"Programming communicating processes is challenging, because it requires\nwriting separate programs that perform compatible send and receive actions at\nthe right time during execution. Leaving this task to the programmer can easily\nlead to bugs. Choreographic programming addresses this challenge by equipping\ndevelopers with high-level abstractions for codifying the desired communication\nstructures from a global viewpoint. Given a choreography, implementations of\nthe involved processes can be automatically generated by endpoint projection\n(EPP).\n  While choreographic programming prevents manual mistakes in the\nimplementation of communications, the correctness of a choreographic\nprogramming framework crucially hinges on the correctness of its complex\ncompiler, which has motivated formalisation of theories of choreographic\nprogramming in theorem provers. In this paper, we build upon one of these\nformalisations to construct a toolchain that produces executable code from a\nchoreography."},"conf/sac/Cruz-FilipeM17":{"pdf":"cm17_sac","abstract":"Choreographies are widely used both for the specification and the programming of concurrent and distributed software architectures. Since many of such architectures use asynchronous communications, it is essential to understand how the behaviour described in a choreography can be correctly implemented in asynchronous settings. So far, this problem has been addressed by relying on additional technical machinery, such as ad-hoc syntactic terms, semantics, or equivalences. In this work, we show that such extensions are not needed for choreography languages that support primitives for process spawning and name mobility. Instead, we can just encode asynchronous communications in choreographies themselves, yielding a simpler approach."},"conf/concur/CarboneMSY15":{"pdf":"cmsy15","abstract":"We propose a Curry-Howard correspondence between a language for programming multiparty sessions and a generalisation of Classical Linear Logic (CLL). In this framework, propositions correspond to the local behaviour of a participant in a multiparty session type, proofs to processes, and proof normalisation to executing communications. Our key contribution is generalising duality, from CLL, to a new notion of n-ary compatibility, called coherence. Building on coherence as a principle of compositionality, we generalise the cut rule of CLL to a new rule for composing many processes communicating in a multiparty session. We prove the soundness of our model by showing the admissibility of our new rule, which entails deadlock-freedom via our correspondence."},"journals/corr/abs-0906-3920":{"pdf":"gm09","abstract":"This paper is about a new way for programming distributed applications: the\nservice-oriented one. It is a concept paper based upon our experience in\ndeveloping a theory and a language for programming services. Both the\ntheoretical formalization and the language interpreter showed us the evidence\nthat a new programming paradigm exists. In this paper we illustrate the basic\nfeatures it is characterized by."},"conf/tgc/LaneseBM10":{"pdf":"lbm10","abstract":"We propose a new approach to dynamic adaptation, based on the combination of adaptation hooks provided by the adaptable application specifying where adaptation can happen, and adaptation rules external to the application, specifying when and how adaptation can be performed. We discuss different design choices that have to be considered when using such an approach, and then we propose a possible solution. We describe the solution in details, we apply it to a sample scenario and we implement it on top of the language Jolie."},"conf/concur/CarboneLMSW16":{"pdf":"clmsw16","abstract":"Wadler introduced Classical Processes (CP), a calculus based on a propositions-as-types correspondence between propositions of classical linear logic and session types. Carbone et al. introduced Multiparty Classical Processes, a calculus that generalises CP to multiparty session types, by replacing the duality of classical linear logic (relating two types) with a more general notion of coherence (relating an arbitrary number of types). This paper introduces variants of CP and MCP, plus a new intermediate calculus of Globally-governed Classical Processes (GCP). We show a tight relation between these three calculi, giving semantics-preserving translations from GCP to CP and from MCP to GCP. The translation from GCP to CP interprets a coherence proof as an arbiter process that mediates communications in a session, while MCP adds annotations that permit processes to communicate directly without centralised control."},"conf/forte/Cruz-FilipeLM23":{"pdf":"clm23","abstract":"<p>Programming communicating processes is challenging, because it requires writing separate programs that perform compatible send and receive actions at the right time during execution. Leaving this task to the programmer can easily lead to bugs. Choreographic programming addresses this challenge by equipping developers with high-level abstractions for codifying the desired communication structures from a global viewpoint. Given a choreography, implementations of the involved processes can be automatically generated by endpoint projection (EPP).<\/p><p>While choreographic programming prevents manual mistakes in the implementation of communications, the correctness of a choreographic programming framework crucially hinges on the correctness of its complex compiler, which has motivated formalisation of theories of choreographic programming in theorem provers. In this paper, we build upon one of these formalisations to construct a toolchain that produces executable code from a choreography.<\/p>"},"journals/corr/abs-1804-08976":{"abstract":"We present Cho-Reo-graphies (CR), a new language model that unites two\npowerful programming paradigms for concurrent software based on communicating\nprocesses: Choreographic Programming and Exogenous Coordination. In CR,\nprogrammers specify the desired communications among processes using a\nchoreography, and define how communications should be concretely animated by\nconnectors given as constraint automata (e.g., synchronous barriers and\nasynchronous multi-casts). CR is the first choreography calculus where\ndifferent communication semantics (determined by connectors) can be freely\nmixed; since connectors are user-defined, CR also supports many communication\nsemantics that were previously unavailable for choreographies. We develop a\nstatic analysis that guarantees that a choreography in CR and its user-defined\nconnectors are compatible, define a compiler from choreographies to a process\ncalculus based on connectors, and prove that compatibility guarantees\ndeadlock-freedom of the compiled process implementations."},"conf/forte/GiallorenzoMG18":{"pdf":"gmg18","abstract":"<p>Choreographic Programming is a paradigm for distributed programming, where high-level \u201CAlice and Bob\u201D descriptions of communications (choreographies) are used to synthesise correct-by-construction programs. However, implementations of choreographic models use message routing technologies distant from their related theoretical models (e.g., CCS\/π channels). This drives implementers to mediate discrepancies with the theory through undocumented, unproven adaptations, weakening the reliability of their implementations.<\/p><p>As a solution, we propose the framework of Applied Choreographies (AC). In AC, programmers write choreographies in a language that follows the standard syntax and semantics of previous works. Then, choreographies are compiled to a real-world execution model for Service-Oriented Computing (SOC). To manage the complexity of this task, our compilation happens in three steps, respectively dealing with: implementing name-based communications using the concrete mechanism found in SOC, projecting a choreography to a set of processes, and translating processes to a distributed implementation in terms of services.<\/p>"},"journals/corr/abs-1711-11211":{"pdf":"cm17-ice","abstract":"Choreographic Programming is a paradigm for the development of concurrent\nsoftware, where deadlocks are prevented syntactically. However, choreography\nlanguages are typically synchronous, whereas many real-world systems have\nasynchronous communications. Previous attempts at enriching choreographies with\nasynchrony rely on ad-hoc constructions, whose adequacy is only argued\ninformally. In this work, we formalise the properties that an asynchronous\nsemantics for choreographies should have: messages can be sent without the\nintended receiver being ready, and all sent messages are eventually received.\nWe explore how out-of-order execution, used in choreographies for modelling\nconcurrency, can be exploited to endow choreographies with an asynchronous\nsemantics. Our approach satisfies the properties we identified. We show how our\ndevelopment yields a pleasant correspondence with FIFO-based asynchronous\nmessaging, modelled in a process calculus, and discuss how it can be adopted in\nmore complex choreography models."},"conf/ictac/Cruz-FilipeGLMP22":{"pdf":"cglmp22","abstract":"<p>Choreographic programming is an emerging programming paradigm for concurrent and distributed systems, where developers write the communications that should be enacted and a compiler then automatically generates a distributed implementation.<\/p><p>Currently, the most advanced incarnation of the paradigm is Choral, an object-oriented choreographic programming language that targets Java. Choral deviated significantly from known theories of choreographies, and in particular introduced the possibility of expressing higher-order choreographies that are fully distributed.<\/p><p>In this article, we introduce Chorλ, the first functional choreographic programming language. It is also the first theory that explains the core ideas of higher-order choreographic programming. We show that bridging the gap between practice and theory requires developing a new evaluation strategy and typing discipline for λ terms that accounts for the distributed nature of computation in choreographies.<\/p>"},"journals/corr/LaneseMZ13":{"pdf":"lmz13","abstract":"Choreographies are global descriptions of system behaviors, from which the\nlocal behavior of each endpoint entity can be obtained automatically through\nprojection. To guarantee that its projection is correct, i.e. it has the same\nbehaviors of the original choreography, a choreography usually has to respect\nsome coherency conditions. This restricts the set of choreographies that can be\nprojected.\n  In this paper, we present a transformation for amending choreographies that\ndo not respect common syntactic conditions for projection correctness.\nSpecifically, our transformation automatically reduces the amount of\nconcurrency, and it infers and adds hidden communications that make the\nresulting choreography respect the desired conditions, while preserving its\nbehavior."},"conf/tgc/MontesiS10":{"pdf":"ms10","abstract":"<p>We present a model of components following the process calculus approach. The main problem was isolating primitives that capture the relevant concepts of component-based systems. The key features of the calculus are: a hierarchical structure of components; a prominent role to input\/output interfaces; the possibility of stopping and capturing components; a mechanism of channel interactions, orthogonal to the activity of components, which may produce tunneling effects that bypass the component hierarchy.<\/p><p>We present the calculus, explain the syntax, formulate its operational semantics and a basic type system. We show a number of examples of use of the calculus, with particular emphasis to common evolvability patterns for components.<\/p>"},"journals/corr/MontesiW16":{"pdf":"mw16","abstract":"We review some of the most widely used patterns for the programming of\nmicroservices: circuit breaker, service discovery, and API gateway. By\nsystematically analysing different deployment strategies for these patterns, we\nreach new insight especially for the application of circuit breakers. We also\nevaluate the applicability of Jolie, a language for the programming of\nmicroservices, for these patterns and report on other standard frameworks\noffering similar solutions. Finally, considerations for future developments are\npresented."},"conf/fossacs/Cruz-FilipeLM17":{"pdf":"clm17","abstract":"<p>Choreographies are global descriptions of interactions among concurrent components, most notably used in the settings of verification and synthesis of correct-by-construction software. They require a top-down approach: programmers first write choreographies, and then use them to verify or synthesize their programs. However, most software does not come with choreographies yet, which prevents their application. To attack this problem, previous work investigated choreography extraction, which automatically constructs a choreography that describes the behavior of a given set of programs or protocol specifications.<\/p><p>We propose a new extraction methodology that improves on the state of the art: we can deal with programs that are equipped with state and internal computation; time complexity is dramatically better; and we capture programs that work by exploiting asynchronous communication.<\/p>"},"journals/entcs/MontesiGLZ07":{"path":"jolie-a-java-orchestration-engine-interpreter-engine","pdf":"mglz07","abstract":"Service oriented computing is an emerging paradigm for programming distributed applications based on services. Services are simple software elements that supply their functionalities by exhibiting their interfaces and that can be invoked by exploiting simple communication primitives. The emerging mechanism exploited in service oriented computing for composing services \u2013 in order to provide more complex functionalities \u2013 is by means of orchestrators. An orchestrator is able to invoke and coordinate other services by exploiting typical workflow patterns such as parallel composition, sequencing and choices. Examples of orchestration languages are XLANG [5] and WS-BPEL [7]. In this paper we present JOLIE, an interpreter and engine for orchestration programs. The main novelties of JOLIE are that it provides an easy to use development environment (because it supports a more programmer friendly C\/Java-like syntax instead of an XML-based syntax) and it is based on a solid mathematical underlying model (developed in previous works of the authors [2,3,4])."},"journals/corr/abs-2205-02636":{"path":"implementing-choreography-extraction-complete-arxiv","abstract":"Choreographies are global descriptions of interactions among concurrent\ncomponents, most notably used in the settings of verification and synthesis of\ncorrect-by-construction software. They require a top-down approach: programmers\nfirst write choreographies, and then use them to verify or synthesize their\nprograms. However, most software does not come with choreographies yet, which\nprevents their application. To attack this problem, previous work investigated\nchoreography extraction, which automatically constructs a choreography that\ndescribes the behaviour of a given set of programs or protocol specifications.\n  We propose a new extraction methodology that improves on the state of the\nart: we can deal with programs that are equipped with state and internal\ncomputation and time complexity is dramatically better. We also implement this\ntheory and show that, in spite of its theoretical exponential complexity, it is\nusable in practice. We discuss the data structures needed for an efficient\nimplementation, introduce some optimisations, and perform a systematic\npractical evaluation."},"journals/corr/abs-1811-02209":{"peerReviewedVersion":"journals\/pacmpl\/KokkeMP19","abstract":"We present Hypersequent Classical Processes (HCP), a revised interpretation\nof the \"Proofs as Processes\" correspondence between linear logic and the\n{\\pi}-calculus initially proposed by Abramsky [1994], and later developed by\nBellin and Scott [1994], Caires and Pfenning [2010], and Wadler [2014], among\nothers. HCP mends the discrepancies between linear logic and the syntax and\nobservable semantics of parallel composition in the {\\pi}-calculus, by\nconservatively extending linear logic to hyperenvironments (collections of\nenvironments, inspired by the hypersequents by Avron [1991]). Separation of\nenvironments in hyperenvironments is internalised by $\\otimes$ and corresponds\nto parallel process behaviour. Thanks to this property, for the first time we\nare able to extract a labelled transition system (lts) semantics from proof\nrewritings. Leveraging the information on parallelism at the level of types, we\nobtain a logical reconstruction of the delayed actions that Merro and Sangiorgi\n[2004] formulated to model non-blocking I\/O in the {\\pi}-calculus. We define a\ndenotational semantics for processes based on Brzozowski derivatives, and\nuncover that non-interference in HCP corresponds to Fubini's theorem of double\nantiderivation. Having an lts allows us to validate HCP using the standard\ntoolbox of behavioural theory. We instantiate bisimilarity and barbed\ncongruence for HCP, and obtain a full abstraction result: bisimilarity,\ndenotational equivalence, and barbed congruence coincide."},"journals/corr/abs-2302-14622":{"pdf":"cm23-arxiv","abstract":"Choreographic programming is a paradigm where developers write the global\nspecification (called choreography) of a communicating system, and then a\ncorrect-by-construction distributed implementation is compiled automatically.\nUnfortunately, it is possible to write choreographies that cannot be compiled,\nbecause of issues related to an agreement property known as knowledge of\nchoice. This forces programmers to reason manually about implementation details\nthat may be orthogonal to the protocol that they are writing.\n  Amendment is an automatic procedure for repairing uncompilable\nchoreographies. We present a formalisation of amendment from the literature,\nbuilt upon an existing formalisation of choreographic programming. However, in\nthe process of formalising the expected properties of this procedure, we\ndiscovered a subtle counterexample that invalidates the original published and\npeer-reviewed pen-and-paper theory. We discuss how using a theorem prover led\nus to both finding the issue, and stating and proving a correct formulation of\nthe properties of amendment."},"journals/scp/GiallorenzoMPR23":{"pdf":"gmpr23","abstract":"We introduce LEMMA2Jolie, a tool for translating domain models of microservice architectures given in LEMMA into concrete APIs of microservices in the Jolie programming language. Our tool combines the state of the art for the design and implementation of microservices: developers can use Domain-Driven Design (DDD) for the construction of the domain models of a microservice architecture, and then automatically transition to a serviceoriented programming language that provides native linguistic support for implementing the behaviour of each microservice."},"journals/jar/CruzFilipeMP23":{"pdf":"cmp23","abstract":"<jats:p>Choreographic programming is a paradigm for writing coordination plans for distributed systems from a global point of view, from which correct-by-construction decentralised implementations can be generated automatically. Theory of choreographies typically includes a number of complex results that are proved by structural induction. The high number of cases and the subtle details in some of these proofs has led to important errors being found in published works. In this work, we formalise the theory of a choreographic programming language in Coq. Our development includes the basic properties of this language, a proof of its Turing completeness, a compilation procedure to a process language, and an operational characterisation of the correctness of this procedure. Our formalisation experience illustrates the benefits of using a theorem prover: we get both an additional degree of confidence from the mechanised proof, and a significant simplification of the underlying theory. Our results offer a foundation for the future formal development of choreographic languages.<\/jats:p>"},"conf/birthday/LaneseMZ15":{"pdf":"lmz15","abstract":"Jolie is an orchestration language conceived during Sensoria, an FP7 European project led by Martin Wirsing in the time frame 2005\u20132010. Jolie was designed having in mind both the novel \u2013at project time\u2013 concepts related to Service-Oriented Computing and the traditional approach to the modelling of concurrency typical of process calculi. The foundational work done around Jolie during Sensoria has subsequently produced many concrete results. In this paper we focus on two distinct advancements, one aiming at the development of dynamically adaptable orchestrated systems and one focusing on global choreographic specifications. These works, more recently, contributed to the realisation of a framework for programming dynamically evolvable distributed ServiceOriented applications that are correct-by-construction."},"conf/itp/Cruz-FilipeMP21":{"pdf":"cmp21","abstract":"<p>The theory of choreographic languages typically includes a number of complex results that are proved by structural induction. The high number of cases and the subtle details in some of them lead to long reviewing processes, and occasionally to errors being found in published proofs. In this work, we take a published proof of Turing completeness of a choreographic language and formalise it in Coq. Our development includes formalising the choreographic language, its basic properties, Kleene\u2019s theory of partial recursive functions, the encoding of these functions as choreographies, and a proof that this encoding is correct.<\/p><p>With this effort, we show that theorem proving can be a very useful tool in the field of choreographic languages: besides the added degree of confidence that we get from a mechanised proof, the formalisation process led us to a significant simplification of the underlying theory. Our results offer a foundation for the future formal development of choreographic languages.<\/p>"}}